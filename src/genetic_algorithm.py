import networkx as nx
import random
import numpy as np
import os
import pickle

from preprocess_manual import get_z1_z2_projection

# Parameters
population_size = 20
mutation_rate = 0.05
crossover_rate = 0.3
number_of_nodes = 12  # This might become a range if you want to evolve this too
generations = 200
save_path = "best_graphs"  # Directory to save best parameter sets

if not os.path.exists(save_path):
    os.makedirs(save_path)

def calculate_fitness(params):
    """Calculate fitness based on the graph generated by the parameters."""
    graph = nx.random_geometric_graph(params['n'], params['radius'])
    target_point = np.array([3.75, 0])
    coordinate_matrix_of_graph = get_z1_z2_projection(graph)
    print(coordinate_matrix_of_graph)
    return -np.linalg.norm(coordinate_matrix_of_graph - target_point)

def initialize_population(size, n_range, radius_range):
    return [{'n': random.randint(*n_range), 'radius': random.uniform(*radius_range)} for _ in range(size)]

def select_parent(population, fitnesses):
    tournament = random.sample(list(zip(population, fitnesses)), 3)
    return max(tournament, key=lambda x: x[1])[0]

def crossover(parent1, parent2):
    offspring = {'n': (parent1['n'] + parent2['n']) // 2,
                 'radius': (parent1['radius'] + parent2['radius']) / 2}
    return offspring

def mutate(params, mutation_rate, n_range, radius_range):
    if random.random() < mutation_rate:
        params['n'] = random.randint(*n_range)
    if random.random() < mutation_rate:
        params['radius'] = random.uniform(*radius_range)
    return params

def save_graph(params, generation, fitness, index):
    # Generate the graph using the best evolved parameters
    graph = nx.random_geometric_graph(params['n'], params['radius'])
    filename = f"{save_path}/gen_{generation}_idx_{index}_fit_{fitness:.2f}.pkl"
    with open(filename, 'wb') as f:
        pickle.dump(graph, f)

import matplotlib.pyplot as plt

def genetic_algorithm():
    n_range = (10, 20)  # Define ranges for 'n'
    radius_range = (0.1, 0.9)  # Define ranges for 'radius'
    population = initialize_population(population_size, n_range, radius_range)
    best_fitness = float('-inf')
    best_params = None
    fitness_history = []  # To store the best fitness of each generation

    for generation in range(generations):
        fitnesses = [calculate_fitness(params) for params in population]
        generation_best_fitness = max(fitnesses)
        fitness_history.append(generation_best_fitness)  # Add the best fitness of the current generation to the history
        new_population = []
        for i in range(population_size // 2):
            parent1 = select_parent(population, fitnesses)
            parent2 = select_parent(population, fitnesses)
            if random.random() < crossover_rate:
                offspring1 = crossover(parent1, parent2)
                offspring2 = crossover(parent2, parent1)
            else:
                offspring1, offspring2 = parent1, parent2
            offspring1 = mutate(offspring1, mutation_rate, n_range, radius_range)
            offspring2 = mutate(offspring2, mutation_rate, n_range, radius_range)
            new_population.extend([offspring1, offspring2])

        population = new_population
        if generation_best_fitness > best_fitness:
            best_fitness = generation_best_fitness
            best_params_index = fitnesses.index(generation_best_fitness)
            best_params = population[best_params_index]
            save_graph(best_params, generation + 1, best_fitness, best_params_index)

        print(f"Generation {generation + 1}, Best fitness: {best_fitness}")

    # Plotting the fitness history
    plt.figure(figsize=(10, 6))
    plt.plot(range(1, generations + 1), fitness_history, marker='o', linestyle='-', color='b')
    plt.title('Fitness Evolution')
    plt.xlabel('Generation')
    plt.ylabel('Best Fitness')
    plt.grid(True)
    plt.show()

# Ensure you have defined all other functions and necessary imports before calling genetic_algorithm()
genetic_algorithm()